"""
This type stub file was generated by pyright.
"""

import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import ortools.util.optional_boolean_pb2
import typing
import typing_extensions

"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor
class _MPSolverResponseStatus:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ...


class _MPSolverResponseStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_MPSolverResponseStatus.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    MPSOLVER_OPTIMAL: _MPSolverResponseStatus.ValueType
    MPSOLVER_FEASIBLE: _MPSolverResponseStatus.ValueType
    MPSOLVER_INFEASIBLE: _MPSolverResponseStatus.ValueType
    MPSOLVER_UNBOUNDED: _MPSolverResponseStatus.ValueType
    MPSOLVER_ABNORMAL: _MPSolverResponseStatus.ValueType
    MPSOLVER_NOT_SOLVED: _MPSolverResponseStatus.ValueType
    MPSOLVER_MODEL_IS_VALID: _MPSolverResponseStatus.ValueType
    MPSOLVER_CANCELLED_BY_USER: _MPSolverResponseStatus.ValueType
    MPSOLVER_UNKNOWN_STATUS: _MPSolverResponseStatus.ValueType
    MPSOLVER_MODEL_INVALID: _MPSolverResponseStatus.ValueType
    MPSOLVER_MODEL_INVALID_SOLUTION_HINT: _MPSolverResponseStatus.ValueType
    MPSOLVER_MODEL_INVALID_SOLVER_PARAMETERS: _MPSolverResponseStatus.ValueType
    MPSOLVER_SOLVER_TYPE_UNAVAILABLE: _MPSolverResponseStatus.ValueType
    MPSOLVER_INCOMPATIBLE_OPTIONS: _MPSolverResponseStatus.ValueType
    ...


class MPSolverResponseStatus(_MPSolverResponseStatus, metaclass=_MPSolverResponseStatusEnumTypeWrapper):
    """Status returned by the solver. They follow a hierarchical nomenclature, to
    allow us to add more enum values in the future. Clients should use
    InCategory() to match these enums, with the following C++ pseudo-code:

    bool InCategory(MPSolverResponseStatus status, MPSolverResponseStatus cat) {
      if (cat == MPSOLVER_OPTIMAL) return status == MPSOLVER_OPTIMAL;
      while (status > cat) status >>= 4;
      return status == cat;
    }
    Normal responses -- the model was valid, and the solver ran.
    These statuses should be "somewhat" repeatable, modulo the fact that the
    solver's time limit makes it undeterministic, and could change a FEASIBLE
    model to an OPTIMAL and vice-versa (the others, except NOT_SOLVED, should
    normally be deterministic). Also, the solver libraries can be buggy.
    """
    ...


MPSOLVER_OPTIMAL: MPSolverResponseStatus.ValueType
MPSOLVER_FEASIBLE: MPSolverResponseStatus.ValueType
MPSOLVER_INFEASIBLE: MPSolverResponseStatus.ValueType
MPSOLVER_UNBOUNDED: MPSolverResponseStatus.ValueType
MPSOLVER_ABNORMAL: MPSolverResponseStatus.ValueType
MPSOLVER_NOT_SOLVED: MPSolverResponseStatus.ValueType
MPSOLVER_MODEL_IS_VALID: MPSolverResponseStatus.ValueType
MPSOLVER_CANCELLED_BY_USER: MPSolverResponseStatus.ValueType
MPSOLVER_UNKNOWN_STATUS: MPSolverResponseStatus.ValueType
MPSOLVER_MODEL_INVALID: MPSolverResponseStatus.ValueType
MPSOLVER_MODEL_INVALID_SOLUTION_HINT: MPSolverResponseStatus.ValueType
MPSOLVER_MODEL_INVALID_SOLVER_PARAMETERS: MPSolverResponseStatus.ValueType
MPSOLVER_SOLVER_TYPE_UNAVAILABLE: MPSolverResponseStatus.ValueType
MPSOLVER_INCOMPATIBLE_OPTIONS: MPSolverResponseStatus.ValueType
global___MPSolverResponseStatus = MPSolverResponseStatus
class MPVariableProto(google.protobuf.message.Message):
    """A variable is always constrained in the form:
       lower_bound <= x <= upper_bound
    where lower_bound and upper_bound:
    - Can form a singleton: x = constant = lower_bound = upper_bound.
    - Can form a finite interval: lower_bound <= x <= upper_bound. (x is boxed.)
    - Can form a semi-infinite interval.
        - lower_bound = -infinity: x <= upper_bound.
        - upper_bound = +infinity: x >= lower_bound.
    - Can form the infinite interval: lower_bound = -infinity and
      upper_bound = +infinity, x is free.
    MPVariableProto furthermore stores:
     - The coefficient of the variable in the objective.
     - Whether the variable is integer.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    LOWER_BOUND_FIELD_NUMBER: builtins.int
    UPPER_BOUND_FIELD_NUMBER: builtins.int
    OBJECTIVE_COEFFICIENT_FIELD_NUMBER: builtins.int
    IS_INTEGER_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    BRANCHING_PRIORITY_FIELD_NUMBER: builtins.int
    lower_bound: builtins.float
    upper_bound: builtins.float
    objective_coefficient: builtins.float
    is_integer: builtins.bool
    name: typing.Text
    branching_priority: builtins.int
    def __init__(self, *, lower_bound: typing.Optional[builtins.float] = ..., upper_bound: typing.Optional[builtins.float] = ..., objective_coefficient: typing.Optional[builtins.float] = ..., is_integer: typing.Optional[builtins.bool] = ..., name: typing.Optional[typing.Text] = ..., branching_priority: typing.Optional[builtins.int] = ...) -> None:
        ...
    
    def HasField(self, field_name: typing_extensions.Literal["branching_priority", b"branching_priority", "is_integer", b"is_integer", "lower_bound", b"lower_bound", "name", b"name", "objective_coefficient", b"objective_coefficient", "upper_bound", b"upper_bound"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["branching_priority", b"branching_priority", "is_integer", b"is_integer", "lower_bound", b"lower_bound", "name", b"name", "objective_coefficient", b"objective_coefficient", "upper_bound", b"upper_bound"]) -> None:
        ...
    


global___MPVariableProto = MPVariableProto
class MPConstraintProto(google.protobuf.message.Message):
    """A linear constraint is always of the form:
    lower_bound <= sum of linear term elements <= upper_bound,
    where lower_bound and upper_bound:
    - Can form a singleton: lower_bound == upper_bound. The constraint is an
      equation.
    - Can form a finite interval [lower_bound, upper_bound]. The constraint is
      both lower- and upper-bounded, i.e. "boxed".
    - Can form a semi-infinite interval. lower_bound = -infinity: the constraint
      is upper-bounded. upper_bound = +infinity: the constraint is lower-bounded.
    - Can form the infinite interval: lower_bound = -infinity and
      upper_bound = +infinity. The constraint is free.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VAR_INDEX_FIELD_NUMBER: builtins.int
    COEFFICIENT_FIELD_NUMBER: builtins.int
    LOWER_BOUND_FIELD_NUMBER: builtins.int
    UPPER_BOUND_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    IS_LAZY_FIELD_NUMBER: builtins.int
    @property
    def var_index(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """var_index[i] is the variable index (w.r.t. to "variable" field of
        MPModelProto) of the i-th linear term involved in this constraint, and
        coefficient[i] is its coefficient. Only the terms with non-zero
        coefficients need to appear. var_index may not contain duplicates.
        """
        ...
    
    @property
    def coefficient(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """Must be finite."""
        ...
    
    lower_bound: builtins.float
    upper_bound: builtins.float
    name: typing.Text
    is_lazy: builtins.bool
    def __init__(self, *, var_index: typing.Optional[typing.Iterable[builtins.int]] = ..., coefficient: typing.Optional[typing.Iterable[builtins.float]] = ..., lower_bound: typing.Optional[builtins.float] = ..., upper_bound: typing.Optional[builtins.float] = ..., name: typing.Optional[typing.Text] = ..., is_lazy: typing.Optional[builtins.bool] = ...) -> None:
        ...
    
    def HasField(self, field_name: typing_extensions.Literal["is_lazy", b"is_lazy", "lower_bound", b"lower_bound", "name", b"name", "upper_bound", b"upper_bound"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["coefficient", b"coefficient", "is_lazy", b"is_lazy", "lower_bound", b"lower_bound", "name", b"name", "upper_bound", b"upper_bound", "var_index", b"var_index"]) -> None:
        ...
    


global___MPConstraintProto = MPConstraintProto
class MPGeneralConstraintProto(google.protobuf.message.Message):
    """General constraints. See each individual proto type for more information."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    INDICATOR_CONSTRAINT_FIELD_NUMBER: builtins.int
    SOS_CONSTRAINT_FIELD_NUMBER: builtins.int
    QUADRATIC_CONSTRAINT_FIELD_NUMBER: builtins.int
    ABS_CONSTRAINT_FIELD_NUMBER: builtins.int
    AND_CONSTRAINT_FIELD_NUMBER: builtins.int
    OR_CONSTRAINT_FIELD_NUMBER: builtins.int
    MIN_CONSTRAINT_FIELD_NUMBER: builtins.int
    MAX_CONSTRAINT_FIELD_NUMBER: builtins.int
    name: typing.Text
    @property
    def indicator_constraint(self) -> global___MPIndicatorConstraint:
        ...
    
    @property
    def sos_constraint(self) -> global___MPSosConstraint:
        ...
    
    @property
    def quadratic_constraint(self) -> global___MPQuadraticConstraint:
        ...
    
    @property
    def abs_constraint(self) -> global___MPAbsConstraint:
        ...
    
    @property
    def and_constraint(self) -> global___MPArrayConstraint:
        """All variables in "and" constraints must be Boolean.
        resultant_var = and(var_1, var_2... var_n)
        """
        ...
    
    @property
    def or_constraint(self) -> global___MPArrayConstraint:
        """All variables in "or" constraints must be Boolean.
        resultant_var = or(var_1, var_2... var_n)
        """
        ...
    
    @property
    def min_constraint(self) -> global___MPArrayWithConstantConstraint:
        """resultant_var = min(var_1, var_2, ..., constant)"""
        ...
    
    @property
    def max_constraint(self) -> global___MPArrayWithConstantConstraint:
        """resultant_var = max(var_1, var_2, ..., constant)"""
        ...
    
    def __init__(self, *, name: typing.Optional[typing.Text] = ..., indicator_constraint: typing.Optional[global___MPIndicatorConstraint] = ..., sos_constraint: typing.Optional[global___MPSosConstraint] = ..., quadratic_constraint: typing.Optional[global___MPQuadraticConstraint] = ..., abs_constraint: typing.Optional[global___MPAbsConstraint] = ..., and_constraint: typing.Optional[global___MPArrayConstraint] = ..., or_constraint: typing.Optional[global___MPArrayConstraint] = ..., min_constraint: typing.Optional[global___MPArrayWithConstantConstraint] = ..., max_constraint: typing.Optional[global___MPArrayWithConstantConstraint] = ...) -> None:
        ...
    
    def HasField(self, field_name: typing_extensions.Literal["abs_constraint", b"abs_constraint", "and_constraint", b"and_constraint", "general_constraint", b"general_constraint", "indicator_constraint", b"indicator_constraint", "max_constraint", b"max_constraint", "min_constraint", b"min_constraint", "name", b"name", "or_constraint", b"or_constraint", "quadratic_constraint", b"quadratic_constraint", "sos_constraint", b"sos_constraint"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["abs_constraint", b"abs_constraint", "and_constraint", b"and_constraint", "general_constraint", b"general_constraint", "indicator_constraint", b"indicator_constraint", "max_constraint", b"max_constraint", "min_constraint", b"min_constraint", "name", b"name", "or_constraint", b"or_constraint", "quadratic_constraint", b"quadratic_constraint", "sos_constraint", b"sos_constraint"]) -> None:
        ...
    
    def WhichOneof(self, oneof_group: typing_extensions.Literal["general_constraint", b"general_constraint"]) -> typing.Optional[typing_extensions.Literal["indicator_constraint", "sos_constraint", "quadratic_constraint", "abs_constraint", "and_constraint", "or_constraint", "min_constraint", "max_constraint"]]:
        ...
    


global___MPGeneralConstraintProto = MPGeneralConstraintProto
class MPIndicatorConstraint(google.protobuf.message.Message):
    """Indicator constraints encode the activation or deactivation of linear
    constraints given the value of one Boolean variable in the model. For
    example:
        y = 0 => 2 * x1 + 3 * x2 >= 42
    The 2 * x1 + 3 * x2 >= 42 constraint is only active if the variable y is
    equal to 0.
    As of 2019/04, only SCIP, CP-SAT and Gurobi support this constraint type.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VAR_INDEX_FIELD_NUMBER: builtins.int
    VAR_VALUE_FIELD_NUMBER: builtins.int
    CONSTRAINT_FIELD_NUMBER: builtins.int
    var_index: builtins.int
    var_value: builtins.int
    @property
    def constraint(self) -> global___MPConstraintProto:
        """The constraint activated by the indicator variable."""
        ...
    
    def __init__(self, *, var_index: typing.Optional[builtins.int] = ..., var_value: typing.Optional[builtins.int] = ..., constraint: typing.Optional[global___MPConstraintProto] = ...) -> None:
        ...
    
    def HasField(self, field_name: typing_extensions.Literal["constraint", b"constraint", "var_index", b"var_index", "var_value", b"var_value"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["constraint", b"constraint", "var_index", b"var_index", "var_value", b"var_value"]) -> None:
        ...
    


global___MPIndicatorConstraint = MPIndicatorConstraint
class MPSosConstraint(google.protobuf.message.Message):
    """Special Ordered Set (SOS) constraints of type 1 or 2.
    See https://en.wikipedia.org/wiki/Special_ordered_set
    As of 2019/04, only SCIP and Gurobi support this constraint type.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Type:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ...
    
    
    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[MPSosConstraint._Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        SOS1_DEFAULT: MPSosConstraint._Type.ValueType
        SOS2: MPSosConstraint._Type.ValueType
        ...
    
    
    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        ...
    
    
    SOS1_DEFAULT: MPSosConstraint.Type.ValueType
    SOS2: MPSosConstraint.Type.ValueType
    TYPE_FIELD_NUMBER: builtins.int
    VAR_INDEX_FIELD_NUMBER: builtins.int
    WEIGHT_FIELD_NUMBER: builtins.int
    type: global___MPSosConstraint.Type.ValueType
    @property
    def var_index(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Variable index (w.r.t. the "variable" field of MPModelProto) of the
        variables in the SOS.
        """
        ...
    
    @property
    def weight(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """Optional: SOS weights. If non-empty, must be of the same size as
        "var_index", and strictly increasing. If empty and required by the
        underlying solver, the 1..n sequence will be given as weights.
        SUBTLE: The weights can help the solver make branch-and-bound decisions
        that fit the underlying optimization model: after each LP relaxation, it
        will compute the "average weight" of the SOS variables, weighted by value
        (this is confusing: here we're using the values as weights), and the binary
        branch decision will be: is the non-zero variable above or below that?
        (weights are strictly monotonous, so the "cutoff" average weight
        corresponds to a "cutoff" index in the var_index sequence).
        """
        ...
    
    def __init__(self, *, type: typing.Optional[global___MPSosConstraint.Type.ValueType] = ..., var_index: typing.Optional[typing.Iterable[builtins.int]] = ..., weight: typing.Optional[typing.Iterable[builtins.float]] = ...) -> None:
        ...
    
    def HasField(self, field_name: typing_extensions.Literal["type", b"type"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["type", b"type", "var_index", b"var_index", "weight", b"weight"]) -> None:
        ...
    


global___MPSosConstraint = MPSosConstraint
class MPQuadraticConstraint(google.protobuf.message.Message):
    """Quadratic constraints of the form lb <= sum a_i x_i + sum b_ij x_i x_j <= ub,
    where a, b, lb and ub are constants, and x are the model's variables.
    Quadratic matrices that are Positive Semi-Definite, Second-Order Cones or
    rotated Second-Order Cones are always accepted. Other forms may or may not be
    accepted depending on the underlying solver used.
    See https://scip.zib.de/doc/html/cons__quadratic_8h.php and
    https://www.gurobi.com/documentation/9.0/refman/constraints.html#subsubsection:QuadraticConstraints
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VAR_INDEX_FIELD_NUMBER: builtins.int
    COEFFICIENT_FIELD_NUMBER: builtins.int
    QVAR1_INDEX_FIELD_NUMBER: builtins.int
    QVAR2_INDEX_FIELD_NUMBER: builtins.int
    QCOEFFICIENT_FIELD_NUMBER: builtins.int
    LOWER_BOUND_FIELD_NUMBER: builtins.int
    UPPER_BOUND_FIELD_NUMBER: builtins.int
    @property
    def var_index(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Sparse representation of linear terms in the quadratic constraint, where
        term i is var_index[i] * coefficient[i].
        `var_index` are variable indices w.r.t the "variable" field in
        MPModelProto, and should be unique.
        """
        ...
    
    @property
    def coefficient(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """Must be finite."""
        ...
    
    @property
    def qvar1_index(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Sparse representation of quadratic terms in the quadratic constraint, where
        term i is qvar1_index[i] * qvar2_index[i] * qcoefficient[i].
        `qvar1_index` and `qvar2_index` are variable indices w.r.t the "variable"
        field in MPModelProto.
        `qvar1_index`, `qvar2_index` and `coefficients` must have the same size.
        If the same unordered pair (qvar1_index, qvar2_index) appears several
        times, the sum of all of the associated coefficients will be applied.
        """
        ...
    
    @property
    def qvar2_index(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        ...
    
    @property
    def qcoefficient(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """Must be finite."""
        ...
    
    lower_bound: builtins.float
    upper_bound: builtins.float
    def __init__(self, *, var_index: typing.Optional[typing.Iterable[builtins.int]] = ..., coefficient: typing.Optional[typing.Iterable[builtins.float]] = ..., qvar1_index: typing.Optional[typing.Iterable[builtins.int]] = ..., qvar2_index: typing.Optional[typing.Iterable[builtins.int]] = ..., qcoefficient: typing.Optional[typing.Iterable[builtins.float]] = ..., lower_bound: typing.Optional[builtins.float] = ..., upper_bound: typing.Optional[builtins.float] = ...) -> None:
        ...
    
    def HasField(self, field_name: typing_extensions.Literal["lower_bound", b"lower_bound", "upper_bound", b"upper_bound"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["coefficient", b"coefficient", "lower_bound", b"lower_bound", "qcoefficient", b"qcoefficient", "qvar1_index", b"qvar1_index", "qvar2_index", b"qvar2_index", "upper_bound", b"upper_bound", "var_index", b"var_index"]) -> None:
        ...
    


global___MPQuadraticConstraint = MPQuadraticConstraint
class MPAbsConstraint(google.protobuf.message.Message):
    """Sets a variable's value to the absolute value of another variable."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VAR_INDEX_FIELD_NUMBER: builtins.int
    RESULTANT_VAR_INDEX_FIELD_NUMBER: builtins.int
    var_index: builtins.int
    resultant_var_index: builtins.int
    def __init__(self, *, var_index: typing.Optional[builtins.int] = ..., resultant_var_index: typing.Optional[builtins.int] = ...) -> None:
        ...
    
    def HasField(self, field_name: typing_extensions.Literal["resultant_var_index", b"resultant_var_index", "var_index", b"var_index"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["resultant_var_index", b"resultant_var_index", "var_index", b"var_index"]) -> None:
        ...
    


global___MPAbsConstraint = MPAbsConstraint
class MPArrayConstraint(google.protobuf.message.Message):
    """Sets a variable's value equal to a function on a set of variables."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VAR_INDEX_FIELD_NUMBER: builtins.int
    RESULTANT_VAR_INDEX_FIELD_NUMBER: builtins.int
    @property
    def var_index(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Variable indices are relative to the "variable" field in MPModelProto."""
        ...
    
    resultant_var_index: builtins.int
    def __init__(self, *, var_index: typing.Optional[typing.Iterable[builtins.int]] = ..., resultant_var_index: typing.Optional[builtins.int] = ...) -> None:
        ...
    
    def HasField(self, field_name: typing_extensions.Literal["resultant_var_index", b"resultant_var_index"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["resultant_var_index", b"resultant_var_index", "var_index", b"var_index"]) -> None:
        ...
    


global___MPArrayConstraint = MPArrayConstraint
class MPArrayWithConstantConstraint(google.protobuf.message.Message):
    """Sets a variable's value equal to a function on a set of variables and,
    optionally, a constant.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VAR_INDEX_FIELD_NUMBER: builtins.int
    CONSTANT_FIELD_NUMBER: builtins.int
    RESULTANT_VAR_INDEX_FIELD_NUMBER: builtins.int
    @property
    def var_index(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Variable indices are relative to the "variable" field in MPModelProto.
        resultant_var = f(var_1, var_2, ..., constant)
        """
        ...
    
    constant: builtins.float
    resultant_var_index: builtins.int
    def __init__(self, *, var_index: typing.Optional[typing.Iterable[builtins.int]] = ..., constant: typing.Optional[builtins.float] = ..., resultant_var_index: typing.Optional[builtins.int] = ...) -> None:
        ...
    
    def HasField(self, field_name: typing_extensions.Literal["constant", b"constant", "resultant_var_index", b"resultant_var_index"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["constant", b"constant", "resultant_var_index", b"resultant_var_index", "var_index", b"var_index"]) -> None:
        ...
    


global___MPArrayWithConstantConstraint = MPArrayWithConstantConstraint
class MPQuadraticObjective(google.protobuf.message.Message):
    """Quadratic part of a model's objective. Added with other objectives (such as
    linear), this creates the model's objective function to be optimized.
    Note: the linear part of the objective currently needs to be specified in the
    MPVariableProto.objective_coefficient fields. If you'd rather have a
    dedicated linear array here, talk to or-core-team@
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    QVAR1_INDEX_FIELD_NUMBER: builtins.int
    QVAR2_INDEX_FIELD_NUMBER: builtins.int
    COEFFICIENT_FIELD_NUMBER: builtins.int
    @property
    def qvar1_index(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Sparse representation of quadratic terms in the objective function, where
        term i is qvar1_index[i] * qvar2_index[i] * coefficient[i].
        `qvar1_index` and `qvar2_index` are variable indices w.r.t the "variable"
        field in MPModelProto.
        `qvar1_index`, `qvar2_index` and `coefficients` must have the same size.
        If the same unordered pair (qvar1_index, qvar2_index) appears several
        times, the sum of all of the associated coefficients will be applied.
        """
        ...
    
    @property
    def qvar2_index(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        ...
    
    @property
    def coefficient(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """Must be finite."""
        ...
    
    def __init__(self, *, qvar1_index: typing.Optional[typing.Iterable[builtins.int]] = ..., qvar2_index: typing.Optional[typing.Iterable[builtins.int]] = ..., coefficient: typing.Optional[typing.Iterable[builtins.float]] = ...) -> None:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["coefficient", b"coefficient", "qvar1_index", b"qvar1_index", "qvar2_index", b"qvar2_index"]) -> None:
        ...
    


global___MPQuadraticObjective = MPQuadraticObjective
class PartialVariableAssignment(google.protobuf.message.Message):
    """This message encodes a partial (or full) assignment of the variables of a
    MPModelProto problem. The indices in var_index should be unique and valid
    variable indices of the associated problem.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VAR_INDEX_FIELD_NUMBER: builtins.int
    VAR_VALUE_FIELD_NUMBER: builtins.int
    @property
    def var_index(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        ...
    
    @property
    def var_value(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        ...
    
    def __init__(self, *, var_index: typing.Optional[typing.Iterable[builtins.int]] = ..., var_value: typing.Optional[typing.Iterable[builtins.float]] = ...) -> None:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["var_index", b"var_index", "var_value", b"var_value"]) -> None:
        ...
    


global___PartialVariableAssignment = PartialVariableAssignment
class MPModelProto(google.protobuf.message.Message):
    """MPModelProto contains all the information for a Linear Programming model."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Annotation(google.protobuf.message.Message):
        """Annotations can be freely added by users who want to attach arbitrary
        payload to the model's variables or constraints.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _TargetType:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ...
        
        
        class _TargetTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[MPModelProto.Annotation._TargetType.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            VARIABLE_DEFAULT: MPModelProto.Annotation._TargetType.ValueType
            CONSTRAINT: MPModelProto.Annotation._TargetType.ValueType
            GENERAL_CONSTRAINT: MPModelProto.Annotation._TargetType.ValueType
            ...
        
        
        class TargetType(_TargetType, metaclass=_TargetTypeEnumTypeWrapper):
            """The target of an Annotation is a single entity (e.g. a variable).
            Several Annotations may apply to the same entity.
            """
            ...
        
        
        VARIABLE_DEFAULT: MPModelProto.Annotation.TargetType.ValueType
        CONSTRAINT: MPModelProto.Annotation.TargetType.ValueType
        GENERAL_CONSTRAINT: MPModelProto.Annotation.TargetType.ValueType
        TARGET_TYPE_FIELD_NUMBER: builtins.int
        TARGET_INDEX_FIELD_NUMBER: builtins.int
        TARGET_NAME_FIELD_NUMBER: builtins.int
        PAYLOAD_KEY_FIELD_NUMBER: builtins.int
        PAYLOAD_VALUE_FIELD_NUMBER: builtins.int
        target_type: global___MPModelProto.Annotation.TargetType.ValueType
        target_index: builtins.int
        target_name: typing.Text
        payload_key: typing.Text
        payload_value: typing.Text
        def __init__(self, *, target_type: typing.Optional[global___MPModelProto.Annotation.TargetType.ValueType] = ..., target_index: typing.Optional[builtins.int] = ..., target_name: typing.Optional[typing.Text] = ..., payload_key: typing.Optional[typing.Text] = ..., payload_value: typing.Optional[typing.Text] = ...) -> None:
            ...
        
        def HasField(self, field_name: typing_extensions.Literal["payload_key", b"payload_key", "payload_value", b"payload_value", "target_index", b"target_index", "target_name", b"target_name", "target_type", b"target_type"]) -> builtins.bool:
            ...
        
        def ClearField(self, field_name: typing_extensions.Literal["payload_key", b"payload_key", "payload_value", b"payload_value", "target_index", b"target_index", "target_name", b"target_name", "target_type", b"target_type"]) -> None:
            ...
        
    
    
    VARIABLE_FIELD_NUMBER: builtins.int
    CONSTRAINT_FIELD_NUMBER: builtins.int
    GENERAL_CONSTRAINT_FIELD_NUMBER: builtins.int
    MAXIMIZE_FIELD_NUMBER: builtins.int
    OBJECTIVE_OFFSET_FIELD_NUMBER: builtins.int
    QUADRATIC_OBJECTIVE_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    SOLUTION_HINT_FIELD_NUMBER: builtins.int
    ANNOTATION_FIELD_NUMBER: builtins.int
    @property
    def variable(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MPVariableProto]:
        """All the variables appearing in the model."""
        ...
    
    @property
    def constraint(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MPConstraintProto]:
        """All the constraints appearing in the model."""
        ...
    
    @property
    def general_constraint(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MPGeneralConstraintProto]:
        """All the general constraints appearing in the model. Note that not all
        solvers support all types of general constraints.
        """
        ...
    
    maximize: builtins.bool
    objective_offset: builtins.float
    @property
    def quadratic_objective(self) -> global___MPQuadraticObjective:
        """Optionally, a quadratic objective.
        As of 2019/06, only SCIP and Gurobi support quadratic objectives.
        """
        ...
    
    name: typing.Text
    @property
    def solution_hint(self) -> global___PartialVariableAssignment:
        """Solution hint.

        If a feasible or almost-feasible solution to the problem is already known,
        it may be helpful to pass it to the solver so that it can be used. A solver
        that supports this feature will try to use this information to create its
        initial feasible solution.

        Note that it may not always be faster to give a hint like this to the
        solver. There is also no guarantee that the solver will use this hint or
        try to return a solution "close" to this assignment in case of multiple
        optimal solutions.
        """
        ...
    
    @property
    def annotation(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MPModelProto.Annotation]:
        ...
    
    def __init__(self, *, variable: typing.Optional[typing.Iterable[global___MPVariableProto]] = ..., constraint: typing.Optional[typing.Iterable[global___MPConstraintProto]] = ..., general_constraint: typing.Optional[typing.Iterable[global___MPGeneralConstraintProto]] = ..., maximize: typing.Optional[builtins.bool] = ..., objective_offset: typing.Optional[builtins.float] = ..., quadratic_objective: typing.Optional[global___MPQuadraticObjective] = ..., name: typing.Optional[typing.Text] = ..., solution_hint: typing.Optional[global___PartialVariableAssignment] = ..., annotation: typing.Optional[typing.Iterable[global___MPModelProto.Annotation]] = ...) -> None:
        ...
    
    def HasField(self, field_name: typing_extensions.Literal["maximize", b"maximize", "name", b"name", "objective_offset", b"objective_offset", "quadratic_objective", b"quadratic_objective", "solution_hint", b"solution_hint"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["annotation", b"annotation", "constraint", b"constraint", "general_constraint", b"general_constraint", "maximize", b"maximize", "name", b"name", "objective_offset", b"objective_offset", "quadratic_objective", b"quadratic_objective", "solution_hint", b"solution_hint", "variable", b"variable"]) -> None:
        ...
    


global___MPModelProto = MPModelProto
class OptionalDouble(google.protobuf.message.Message):
    """To support 'unspecified' double value in proto3, the simplest is to wrap
    any double value in a nested message (has_XXX works for message fields).
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    VALUE_FIELD_NUMBER: builtins.int
    value: builtins.float
    def __init__(self, *, value: typing.Optional[builtins.float] = ...) -> None:
        ...
    
    def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["value", b"value"]) -> None:
        ...
    


global___OptionalDouble = OptionalDouble
class MPSolverCommonParameters(google.protobuf.message.Message):
    """MPSolverCommonParameters holds advanced usage parameters that apply to any of
    the solvers we support.
    All of the fields in this proto can have a value of unspecified. In this
    case each inner solver will use their own safe defaults.
    Some values won't be supported by some solvers. The behavior in that case is
    not defined yet.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _LPAlgorithmValues:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ...
    
    
    class _LPAlgorithmValuesEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[MPSolverCommonParameters._LPAlgorithmValues.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        LP_ALGO_UNSPECIFIED: MPSolverCommonParameters._LPAlgorithmValues.ValueType
        LP_ALGO_DUAL: MPSolverCommonParameters._LPAlgorithmValues.ValueType
        LP_ALGO_PRIMAL: MPSolverCommonParameters._LPAlgorithmValues.ValueType
        LP_ALGO_BARRIER: MPSolverCommonParameters._LPAlgorithmValues.ValueType
        ...
    
    
    class LPAlgorithmValues(_LPAlgorithmValues, metaclass=_LPAlgorithmValuesEnumTypeWrapper):
        ...
    
    
    LP_ALGO_UNSPECIFIED: MPSolverCommonParameters.LPAlgorithmValues.ValueType
    LP_ALGO_DUAL: MPSolverCommonParameters.LPAlgorithmValues.ValueType
    LP_ALGO_PRIMAL: MPSolverCommonParameters.LPAlgorithmValues.ValueType
    LP_ALGO_BARRIER: MPSolverCommonParameters.LPAlgorithmValues.ValueType
    RELATIVE_MIP_GAP_FIELD_NUMBER: builtins.int
    PRIMAL_TOLERANCE_FIELD_NUMBER: builtins.int
    DUAL_TOLERANCE_FIELD_NUMBER: builtins.int
    LP_ALGORITHM_FIELD_NUMBER: builtins.int
    PRESOLVE_FIELD_NUMBER: builtins.int
    SCALING_FIELD_NUMBER: builtins.int
    @property
    def relative_mip_gap(self) -> global___OptionalDouble:
        """The solver stops if the relative MIP gap reaches this value or below.
        The relative MIP gap is an upper bound of the relative distance to the
        optimum, and it is defined as:

          abs(best_bound - incumbent) / abs(incumbent) [Gurobi]
          abs(best_bound - incumbent) / min(abs(best_bound), abs(incumbent)) [SCIP]

        where "incumbent" is the objective value of the best solution found so far
        (i.e., lowest when minimizing, highest when maximizing), and "best_bound"
        is the tightest bound of the objective determined so far (i.e., highest
        when minimizing, and lowest when maximizing). The MIP Gap is sensitive to
        objective offset. If the denominator is 0 the MIP Gap is INFINITY for SCIP
        and Gurobi. Of note, "incumbent" and "best bound" are called "primal bound"
        and "dual bound" in SCIP, respectively.
        Ask or-core-team@ for other solvers.
        """
        ...
    
    @property
    def primal_tolerance(self) -> global___OptionalDouble:
        """Tolerance for primal feasibility of basic solutions: this is the maximum
        allowed error in constraint satisfiability.
        For SCIP this includes integrality constraints. For Gurobi it does not, you
        need to set the custom parameter IntFeasTol.
        """
        ...
    
    @property
    def dual_tolerance(self) -> global___OptionalDouble:
        """Tolerance for dual feasibility.
        For SCIP and Gurobi this is the feasibility tolerance for reduced costs in
        LP solution: reduced costs must all be smaller than this value in the
        improving direction in order for a model to be declared optimal.
        Not supported for other solvers.
        """
        ...
    
    lp_algorithm: global___MPSolverCommonParameters.LPAlgorithmValues.ValueType
    presolve: ortools.util.optional_boolean_pb2.OptionalBoolean.ValueType
    scaling: ortools.util.optional_boolean_pb2.OptionalBoolean.ValueType
    def __init__(self, *, relative_mip_gap: typing.Optional[global___OptionalDouble] = ..., primal_tolerance: typing.Optional[global___OptionalDouble] = ..., dual_tolerance: typing.Optional[global___OptionalDouble] = ..., lp_algorithm: typing.Optional[global___MPSolverCommonParameters.LPAlgorithmValues.ValueType] = ..., presolve: typing.Optional[ortools.util.optional_boolean_pb2.OptionalBoolean.ValueType] = ..., scaling: typing.Optional[ortools.util.optional_boolean_pb2.OptionalBoolean.ValueType] = ...) -> None:
        ...
    
    def HasField(self, field_name: typing_extensions.Literal["dual_tolerance", b"dual_tolerance", "lp_algorithm", b"lp_algorithm", "presolve", b"presolve", "primal_tolerance", b"primal_tolerance", "relative_mip_gap", b"relative_mip_gap", "scaling", b"scaling"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["dual_tolerance", b"dual_tolerance", "lp_algorithm", b"lp_algorithm", "presolve", b"presolve", "primal_tolerance", b"primal_tolerance", "relative_mip_gap", b"relative_mip_gap", "scaling", b"scaling"]) -> None:
        ...
    


global___MPSolverCommonParameters = MPSolverCommonParameters
class MPModelDeltaProto(google.protobuf.message.Message):
    """Encodes a full MPModelProto by way of referencing to a "baseline"
    MPModelProto stored in a file, and a "delta" to apply to this model.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class VariableOverridesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int
        @property
        def value(self) -> global___MPVariableProto:
            ...
        
        def __init__(self, *, key: typing.Optional[builtins.int] = ..., value: typing.Optional[global___MPVariableProto] = ...) -> None:
            ...
        
        def HasField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> builtins.bool:
            ...
        
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    class ConstraintOverridesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int
        @property
        def value(self) -> global___MPConstraintProto:
            ...
        
        def __init__(self, *, key: typing.Optional[builtins.int] = ..., value: typing.Optional[global___MPConstraintProto] = ...) -> None:
            ...
        
        def HasField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> builtins.bool:
            ...
        
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None:
            ...
        
    
    
    BASELINE_MODEL_FILE_PATH_FIELD_NUMBER: builtins.int
    VARIABLE_OVERRIDES_FIELD_NUMBER: builtins.int
    CONSTRAINT_OVERRIDES_FIELD_NUMBER: builtins.int
    baseline_model_file_path: typing.Text
    @property
    def variable_overrides(self) -> google.protobuf.internal.containers.MessageMap[builtins.int, global___MPVariableProto]:
        """The variable protos listed here will override (via MergeFrom()) the ones
        in the baseline model: you only need to specify the fields that change.
        To add a new variable, add it with a new variable index (variable indices
        still need to span a dense integer interval).
        You can't "delete" a variable but you can "neutralize" it by fixing its
        value, setting its objective coefficient to zero, and by nullifying all
        the terms involving it in the constraints.
        """
        ...
    
    @property
    def constraint_overrides(self) -> google.protobuf.internal.containers.MessageMap[builtins.int, global___MPConstraintProto]:
        """Constraints can be changed (or added) in the same way as variables, see
        above. It's mostly like applying MergeFrom(), except that:
        - the "var_index" and "coefficient" fields will be overridden like a map:
          if a key pre-exists, we overwrite its value, otherwise we add it.
        - if you set the lower bound to -inf and the upper bound to +inf, thus
          effectively neutralizing the constraint, the solver will implicitly
          remove all of the constraint's terms.
        """
        ...
    
    def __init__(self, *, baseline_model_file_path: typing.Optional[typing.Text] = ..., variable_overrides: typing.Optional[typing.Mapping[builtins.int, global___MPVariableProto]] = ..., constraint_overrides: typing.Optional[typing.Mapping[builtins.int, global___MPConstraintProto]] = ...) -> None:
        ...
    
    def HasField(self, field_name: typing_extensions.Literal["baseline_model_file_path", b"baseline_model_file_path"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["baseline_model_file_path", b"baseline_model_file_path", "constraint_overrides", b"constraint_overrides", "variable_overrides", b"variable_overrides"]) -> None:
        ...
    


global___MPModelDeltaProto = MPModelDeltaProto
class MPModelRequest(google.protobuf.message.Message):
    """Next id: 17."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _SolverType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ...
    
    
    class _SolverTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[MPModelRequest._SolverType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        CLP_LINEAR_PROGRAMMING: MPModelRequest._SolverType.ValueType
        GLOP_LINEAR_PROGRAMMING: MPModelRequest._SolverType.ValueType
        GLPK_LINEAR_PROGRAMMING: MPModelRequest._SolverType.ValueType
        GUROBI_LINEAR_PROGRAMMING: MPModelRequest._SolverType.ValueType
        XPRESS_LINEAR_PROGRAMMING: MPModelRequest._SolverType.ValueType
        CPLEX_LINEAR_PROGRAMMING: MPModelRequest._SolverType.ValueType
        SCIP_MIXED_INTEGER_PROGRAMMING: MPModelRequest._SolverType.ValueType
        GLPK_MIXED_INTEGER_PROGRAMMING: MPModelRequest._SolverType.ValueType
        CBC_MIXED_INTEGER_PROGRAMMING: MPModelRequest._SolverType.ValueType
        GUROBI_MIXED_INTEGER_PROGRAMMING: MPModelRequest._SolverType.ValueType
        XPRESS_MIXED_INTEGER_PROGRAMMING: MPModelRequest._SolverType.ValueType
        CPLEX_MIXED_INTEGER_PROGRAMMING: MPModelRequest._SolverType.ValueType
        BOP_INTEGER_PROGRAMMING: MPModelRequest._SolverType.ValueType
        SAT_INTEGER_PROGRAMMING: MPModelRequest._SolverType.ValueType
        PDLP_LINEAR_PROGRAMMING: MPModelRequest._SolverType.ValueType
        KNAPSACK_MIXED_INTEGER_PROGRAMMING: MPModelRequest._SolverType.ValueType
        ...
    
    
    class SolverType(_SolverType, metaclass=_SolverTypeEnumTypeWrapper):
        """The solver type, which will select a specific implementation, and will also
        impact the interpretation of the model (i.e. are we solving the problem
        as a mixed integer program or are we relaxing it as a continuous linear
        program?).
        This must remain consistent with MPSolver::OptimizationProblemType.
        """
        ...
    
    
    CLP_LINEAR_PROGRAMMING: MPModelRequest.SolverType.ValueType
    GLOP_LINEAR_PROGRAMMING: MPModelRequest.SolverType.ValueType
    GLPK_LINEAR_PROGRAMMING: MPModelRequest.SolverType.ValueType
    GUROBI_LINEAR_PROGRAMMING: MPModelRequest.SolverType.ValueType
    XPRESS_LINEAR_PROGRAMMING: MPModelRequest.SolverType.ValueType
    CPLEX_LINEAR_PROGRAMMING: MPModelRequest.SolverType.ValueType
    SCIP_MIXED_INTEGER_PROGRAMMING: MPModelRequest.SolverType.ValueType
    GLPK_MIXED_INTEGER_PROGRAMMING: MPModelRequest.SolverType.ValueType
    CBC_MIXED_INTEGER_PROGRAMMING: MPModelRequest.SolverType.ValueType
    GUROBI_MIXED_INTEGER_PROGRAMMING: MPModelRequest.SolverType.ValueType
    XPRESS_MIXED_INTEGER_PROGRAMMING: MPModelRequest.SolverType.ValueType
    CPLEX_MIXED_INTEGER_PROGRAMMING: MPModelRequest.SolverType.ValueType
    BOP_INTEGER_PROGRAMMING: MPModelRequest.SolverType.ValueType
    SAT_INTEGER_PROGRAMMING: MPModelRequest.SolverType.ValueType
    PDLP_LINEAR_PROGRAMMING: MPModelRequest.SolverType.ValueType
    KNAPSACK_MIXED_INTEGER_PROGRAMMING: MPModelRequest.SolverType.ValueType
    MODEL_FIELD_NUMBER: builtins.int
    SOLVER_TYPE_FIELD_NUMBER: builtins.int
    SOLVER_TIME_LIMIT_SECONDS_FIELD_NUMBER: builtins.int
    ENABLE_INTERNAL_SOLVER_OUTPUT_FIELD_NUMBER: builtins.int
    SOLVER_SPECIFIC_PARAMETERS_FIELD_NUMBER: builtins.int
    IGNORE_SOLVER_SPECIFIC_PARAMETERS_FAILURE_FIELD_NUMBER: builtins.int
    MODEL_DELTA_FIELD_NUMBER: builtins.int
    POPULATE_ADDITIONAL_SOLUTIONS_UP_TO_FIELD_NUMBER: builtins.int
    @property
    def model(self) -> global___MPModelProto:
        """The model to be optimized by the server."""
        ...
    
    solver_type: global___MPModelRequest.SolverType.ValueType
    solver_time_limit_seconds: builtins.float
    enable_internal_solver_output: builtins.bool
    solver_specific_parameters: typing.Text
    ignore_solver_specific_parameters_failure: builtins.bool
    @property
    def model_delta(self) -> global___MPModelDeltaProto:
        """Advanced usage: model "delta". If used, "model" must be unset. See the
        definition of MPModelDeltaProto.
        """
        ...
    
    populate_additional_solutions_up_to: builtins.int
    def __init__(self, *, model: typing.Optional[global___MPModelProto] = ..., solver_type: typing.Optional[global___MPModelRequest.SolverType.ValueType] = ..., solver_time_limit_seconds: typing.Optional[builtins.float] = ..., enable_internal_solver_output: typing.Optional[builtins.bool] = ..., solver_specific_parameters: typing.Optional[typing.Text] = ..., ignore_solver_specific_parameters_failure: typing.Optional[builtins.bool] = ..., model_delta: typing.Optional[global___MPModelDeltaProto] = ..., populate_additional_solutions_up_to: typing.Optional[builtins.int] = ...) -> None:
        ...
    
    def HasField(self, field_name: typing_extensions.Literal["enable_internal_solver_output", b"enable_internal_solver_output", "ignore_solver_specific_parameters_failure", b"ignore_solver_specific_parameters_failure", "model", b"model", "model_delta", b"model_delta", "populate_additional_solutions_up_to", b"populate_additional_solutions_up_to", "solver_specific_parameters", b"solver_specific_parameters", "solver_time_limit_seconds", b"solver_time_limit_seconds", "solver_type", b"solver_type"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["enable_internal_solver_output", b"enable_internal_solver_output", "ignore_solver_specific_parameters_failure", b"ignore_solver_specific_parameters_failure", "model", b"model", "model_delta", b"model_delta", "populate_additional_solutions_up_to", b"populate_additional_solutions_up_to", "solver_specific_parameters", b"solver_specific_parameters", "solver_time_limit_seconds", b"solver_time_limit_seconds", "solver_type", b"solver_type"]) -> None:
        ...
    


global___MPModelRequest = MPModelRequest
class MPSolution(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    OBJECTIVE_VALUE_FIELD_NUMBER: builtins.int
    VARIABLE_VALUE_FIELD_NUMBER: builtins.int
    objective_value: builtins.float
    @property
    def variable_value(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        ...
    
    def __init__(self, *, objective_value: typing.Optional[builtins.float] = ..., variable_value: typing.Optional[typing.Iterable[builtins.float]] = ...) -> None:
        ...
    
    def HasField(self, field_name: typing_extensions.Literal["objective_value", b"objective_value"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["objective_value", b"objective_value", "variable_value", b"variable_value"]) -> None:
        ...
    


global___MPSolution = MPSolution
class MPSolveInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    SOLVE_WALL_TIME_SECONDS_FIELD_NUMBER: builtins.int
    SOLVE_USER_TIME_SECONDS_FIELD_NUMBER: builtins.int
    solve_wall_time_seconds: builtins.float
    solve_user_time_seconds: builtins.float
    def __init__(self, *, solve_wall_time_seconds: typing.Optional[builtins.float] = ..., solve_user_time_seconds: typing.Optional[builtins.float] = ...) -> None:
        ...
    
    def HasField(self, field_name: typing_extensions.Literal["solve_user_time_seconds", b"solve_user_time_seconds", "solve_wall_time_seconds", b"solve_wall_time_seconds"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["solve_user_time_seconds", b"solve_user_time_seconds", "solve_wall_time_seconds", b"solve_wall_time_seconds"]) -> None:
        ...
    


global___MPSolveInfo = MPSolveInfo
class MPSolutionResponse(google.protobuf.message.Message):
    """Next id: 12."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    STATUS_FIELD_NUMBER: builtins.int
    STATUS_STR_FIELD_NUMBER: builtins.int
    OBJECTIVE_VALUE_FIELD_NUMBER: builtins.int
    BEST_OBJECTIVE_BOUND_FIELD_NUMBER: builtins.int
    VARIABLE_VALUE_FIELD_NUMBER: builtins.int
    SOLVE_INFO_FIELD_NUMBER: builtins.int
    SOLVER_SPECIFIC_INFO_FIELD_NUMBER: builtins.int
    DUAL_VALUE_FIELD_NUMBER: builtins.int
    REDUCED_COST_FIELD_NUMBER: builtins.int
    ADDITIONAL_SOLUTIONS_FIELD_NUMBER: builtins.int
    status: global___MPSolverResponseStatus.ValueType
    status_str: typing.Text
    objective_value: builtins.float
    best_objective_bound: builtins.float
    @property
    def variable_value(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """Variable values in the same order as the MPModelProto::variable field.
        This is a dense representation. These are set iff 'status' is OPTIMAL or
        FEASIBLE.
        """
        ...
    
    @property
    def solve_info(self) -> global___MPSolveInfo:
        """Contains extra information about the solve, populated if the underlying
        solver (and its interface) supports it. As of 2021/07/19 this is supported
        by SCIP and Gurobi proto solves.
        """
        ...
    
    solver_specific_info: builtins.bytes
    @property
    def dual_value(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """[Advanced usage.]
        Values of the dual variables values in the same order as the
        MPModelProto::constraint field. This is a dense representation.
        These are not set if the problem was solved with a MIP solver (even if
        it is actually a linear program).
        These are set iff 'status' is OPTIMAL or FEASIBLE.
        """
        ...
    
    @property
    def reduced_cost(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """[Advanced usage.]
        Values of the reduced cost of the variables in the same order as the
        MPModelProto::variable. This is a dense representation.
        These are not set if the problem was solved with a MIP solver (even if it
        is actually a linear program).
        These are set iff 'status' is OPTIMAL or FEASIBLE.
        """
        ...
    
    @property
    def additional_solutions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MPSolution]:
        """[Advanced usage.]
        If `MPModelRequest.populate_additional_solutions_up_to` > 0, up to that
        number of additional solutions may be populated here, if available. These
        additional solutions are different than the main solution described by the
        above fields `objective_value` and `variable_value`.
        """
        ...
    
    def __init__(self, *, status: typing.Optional[global___MPSolverResponseStatus.ValueType] = ..., status_str: typing.Optional[typing.Text] = ..., objective_value: typing.Optional[builtins.float] = ..., best_objective_bound: typing.Optional[builtins.float] = ..., variable_value: typing.Optional[typing.Iterable[builtins.float]] = ..., solve_info: typing.Optional[global___MPSolveInfo] = ..., solver_specific_info: typing.Optional[builtins.bytes] = ..., dual_value: typing.Optional[typing.Iterable[builtins.float]] = ..., reduced_cost: typing.Optional[typing.Iterable[builtins.float]] = ..., additional_solutions: typing.Optional[typing.Iterable[global___MPSolution]] = ...) -> None:
        ...
    
    def HasField(self, field_name: typing_extensions.Literal["best_objective_bound", b"best_objective_bound", "objective_value", b"objective_value", "solve_info", b"solve_info", "solver_specific_info", b"solver_specific_info", "status", b"status", "status_str", b"status_str"]) -> builtins.bool:
        ...
    
    def ClearField(self, field_name: typing_extensions.Literal["additional_solutions", b"additional_solutions", "best_objective_bound", b"best_objective_bound", "dual_value", b"dual_value", "objective_value", b"objective_value", "reduced_cost", b"reduced_cost", "solve_info", b"solve_info", "solver_specific_info", b"solver_specific_info", "status", b"status", "status_str", b"status_str", "variable_value", b"variable_value"]) -> None:
        ...
    


global___MPSolutionResponse = MPSolutionResponse
